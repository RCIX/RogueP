TODO

next:

*make a single/simple library (in game concept) and build UI code for display
 *create a library/inventory frame
 *create a command details pane
 *hard code a single library for now
 *most, if not all, libraries will require additional world elements to interact with, so this may have to wait for a good deal of time

short term:

*properly offset world frame/action overlay frame from top left
 *not really needed until pseudoterminal and info pane added
*Start writing the entity piping for world tiles and walls and such
*Make more use of .xp files and such to initialize UI (also pull in more appropriate styling, i'm more or less ignoring the mockup styles I made for now)
*either write single info pane UI frame or different kinds of command pane that render over the rest of the UI
 *At this point I'm thinking a bunch of frames and a single dummy frame that renders a BG
*Implement hardened memory

medium term:

*Revisit introspection to scrape for behaviors
*explore options for world generation (how? what kind of world do I want to generate? will there be levels or is it continuous? etc.)
*Decide an explicit place for UI initialization code to minimize the burden on having a ridiculously huge MenuGame.__init__
*Break out world generation into its own code once I get that far (again, to reduce size on MenuGame.__init)
*Pull out saving code into more distinct code path to support things like RNG initialization and such
*Re-investigate introspection to scrape for behavior subclasses, or some other non hard coded way
*Figure out how to set just the foreground or background color of a tile without changing the character (currently thinking I need a layer on the very top and calls into frame manager to queue tile setting)
*start storing player and world attributes (enemy program stats, library stats, etc.) in configuration files instead of hardcoded (requires finding a data format - probably JSON)

long term (also known as when im bored and want to work on the game side of game development):

*Start looking at how to manage mouse input contextually
*create xp sheets for color palettes, display characters, etc.
*finish drafting title screen and display on main menu
*begin thinking of distinct program types and mechanics beyond "shoot thing, it dies"
*explore options for animation(whether procedural or preloaded from .xp)


Completed thus far (started 9/9):

*Convert action history saving into distinct codepath
*expand terminal to display responses as well (scrape UI events to show what's happening)
*make a simple enemy program that can use memory and has random walk behavior
 *define hostile programs with behavior types, stats, executable libraries, etc. and a single hostileprogram flag
*Move action queue and execution code into entity manager to better support cascading sequences of actions
*make a simple enemy program that can use memory and has random walk behavior
 *Write additional behaviors that operate on hostile programs
 *Generalize movement behavior into other than player stuff
  *Actually probably rename this and or turn into two behaviors, one managing memory creation and one managing the actual movement?
*figure out introspection or other method that auto imports all behavior subclasses for execution so i don't have to re-add them
 *First shot failed, python is incredibly obtuse at this
*Start writing utility code to do things like find adjacent entities, get the player, etc. to cut down on code repetition
*Implement foreground and background coloring for world entities
*Revise action clock frame background
*Add max actions/cycle line on action clock frame